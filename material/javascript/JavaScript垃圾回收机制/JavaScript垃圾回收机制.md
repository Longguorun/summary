# JavaScript垃圾回收机制

### 变量的存放位置

- 栈内存：即基础类型变量，随执行上下文（VO）推进栈中，函数执行完成后，执行上下文被销毁，变量也被回收销毁；栈内存较小
- 堆内存：引用类型实际存放位置，但将引用地址存放于栈内存中；堆内存较大

![在这里插入图片描述](https://img-blog.csdnimg.cn/4458babe7fae4db0bb16be3f73586d75.png#pic_center)

### 垃圾回收机制

垃圾回收其实主要是堆内存变量的回收。

由于垃圾回收很消耗资源，且JavaScript又是单线程执行，因此垃圾回收策略采用了设计策略来避免性能占用过高。

1. 新生代区和老生代区

   ![新老生代视图](https://img-blog.csdnimg.cn/4d0d1931a1084ee39b1deb00c38ed534.png#pic_center)

   - 新生代区——副垃圾回收器

     新生代区的内存占用较小，存放的是新变量，可能会不稳定。在程序执行时，新声明赋值的变量会进入新生代区。内存回收采用Scanvenge机制，即拥有两组内存：from区（对象区）和to区（空闲区）。from区存放还未被回收整理的区域，在某个垃圾回收周期（比如from区快被占满），会递归遍历from区中的变量，将还在被使用的变量复制到to区，遍历完成后，清空from区，并将to区复制到from区。

   - 老生代区——主垃圾回收器

     老生代区内存空间较大，一般存放较稳定的变量。经过一定的判断策略，将新生代区中的变量认定为稳定变量，存放到老生代区中。

     有以下几种策略：

     1. 标记-清除：在变量进入执行环境时，标记为“进入环境”，当变量离开执行环境时。标记为“离开环境”，被标记“进入环境”的变量不会被回收
        被标记“离开环境”的变量则被回收
     2. 标记-整理：通过标清除的内存空间，会出现内存碎片，致使内存的使用效率降低，因此当发现”标记-清除“后，内存仍占用过高时，可使用标记-整理策略：将被标记的变量朝内存空间边界方向统一排列
     3. 引用计数统计：记录每个变量的引用次数，次数为0时代表不会再被引用，可被回收

     在实现垃圾回收时，JavaScript主线程会被占用，因此会造成所谓的全停顿（即阻塞，主线程卡顿），为了避免阻塞，采用了增量标记的方法：

     将每次垃圾回收，分为多次子垃圾回收流程，插针式的在各个代码运行期间执行。

     ![image-20210531144954748](https://img-blog.csdnimg.cn/img_convert/20516c49d005e9d20b6144dbf7d44039.png)

     ![image-20210531145546643](https://img-blog.csdnimg.cn/img_convert/2f7c20abb4e8bc5ceb83e37ea155b663.png)

### 内存泄漏

内存泄漏是指由于疏忽或错误造成程序未能释放已经不在使用的内存。

1、被遗忘的计时器，写在函数内部，闭包内的
2、意外的全局变量{目前eslint会提示语法错误}
3、被遗忘的事件监听器，使用监听器后要移除监听器
4、被遗忘的ES6 set成员
5、被遗忘的订阅发布事件监听器
6、被遗忘的订阅发布事件监听器
7、被遗忘的闭包

查找内存泄漏的方法：利用开发者工具抓内存图

